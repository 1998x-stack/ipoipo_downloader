
# stage 1
```
TMTè¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-70.html
åŒ»è¯åŒ»ç–—å™¨æ¢°è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-53.html
é‡‘èè¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-59.html
æ–°èƒ½æºåŠç”µåŠ›è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-69.html
ç”µå­è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-14.html
æ™ºèƒ½åˆ¶é€ è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-10.html
æ±½è½¦è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-79.html
åœ°äº§åŠæ—…æ¸¸è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-67.html
ç»æµæŠ¥å‘Š	https://ipoipo.cn/tags-34.html
æ–°ææ–™åŠçŸ¿äº§æŠ¥å‘Š	https://ipoipo.cn/tags-24.html
ç”µå•†åŠé”€å”®æŠ¥å‘Š	https://ipoipo.cn/tags-61.html
æ¶ˆè´¹è€…åŠäººç¾¤ç ”ç©¶æŠ¥å‘Š	https://ipoipo.cn/tags-62.html
é£Ÿå“é¥®æ–™é…’æ°´è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-33.html
å¤§æ¶ˆè´¹æŠ¥å‘Š	https://ipoipo.cn/tags-11.html
äººå·¥æ™ºèƒ½AIè¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-85.html
åŒ–å·¥è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-60.html
ç‰©æµè¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-63.html
æ•™è‚²è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-7.html
äº‘è®¡ç®—è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-23.html
èŠ‚èƒ½ç¯ä¿è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-56.html
å†œæ—ç‰§æ¸”è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-64.html
é¤é¥®ä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-73.html
åŒ–å¦†å“è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-74.html
ä½“è‚²åŠç”¨å“è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-25.html
å†›å·¥è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-68.html
å…‰ç”µè¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-76.html
çººç»‡æœè£…è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-39.html
èˆªå¤©é€šè®¯è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-86.html
å®‰å…¨ç›‘æ§è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-77.html
æœåŠ¡ä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-66.html
å® ç‰©è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-84.html
å¥¢ä¾ˆå“åŠç å®æŠ¥å‘Š	https://ipoipo.cn/tags-75.html
ç»éªŒå¹²è´§	https://ipoipo.cn/tags-72.html
æ¯å©´è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-83.html
æ£€æµ‹è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-80.html
å…±äº«ç»æµæŠ¥å‘Š	https://ipoipo.cn/tags-82.html
æ–°åŸºå»ºæŠ¥å‘Š	https://ipoipo.cn/tags-88.html
åšå½©è¡Œä¸šæŠ¥å‘Š	https://ipoipo.cn/tags-54.html
```

# stage2
https://ipoipo.cn/tags-34.html
https://ipoipo.cn/tags-34_2.html
....
get

<div class="wapost card">
    <h2 class="multi-ellipsis">
        <a href="https://ipoipo.cn/post/26028.html" title="ä¸­å›½åœ°æ–¹å…¬å…±æ•°æ®å¼€æ”¾åˆ©ç”¨æŠ¥å‘Šï¼ˆ55é¡µï¼‰">ä¸­å›½åœ°æ–¹å…¬å…±æ•°æ®å¼€æ”¾åˆ©ç”¨æŠ¥å‘Šï¼ˆ55é¡µï¼‰</a>
    </h2>
    <p class="img">
        <a href="https://ipoipo.cn/post/26028.html" target="_blank">
            <img class="img-cover br" src="https://ipoipo.cn/zb_users/cache/thumbs/dc3172611f26bdca6336afa721cc5a19-280-180-1.jpg" title="ä¸­å›½åœ°æ–¹å…¬å…±æ•°æ®å¼€æ”¾åˆ©ç”¨æŠ¥å‘Šï¼ˆ55é¡µï¼‰">
        </a>
    </p>
    <p class="text">ç›®å‰ï¼Œæˆ‘å›½ 27 ä¸ªçœçº§è¡Œæ”¿åŒºï¼ˆä¸å«ç›´è¾–å¸‚å’Œæ¸¯æ¾³å°ï¼‰ä¸­å·²æœ‰ 26 ä¸ªä¸Š çº¿äº†å…¬å…±æ•°æ®å¼€æ”¾å¹³å°ï¼Œå æ€»æ•°...</p>
    <div class="count">
        <span class="view-num"><i class="fa fa-eye"></i>44</span>
        <span class="edit"><i class="fa fa-clock-o"></i>2025-12-22</span> 
    </div>
</div>

# stage3
"https://ipoipo.cn/post/26028.html" change to "https://ipoipo.cn/download/26028.html"


# stage4
<a style="font-size: 12px; color: rgb(0, 102, 204); --darkreader-inline-color: var(--darkreader-text-0066cc, #52b1ff);" href="https://ipo.ai-tag.cn/2025/12/202512021157134086066.zip" data-darkreader-inline-color="">2025ä¸­å›½åœ°æ–¹å…¬å…±æ•°æ®å¼€æ”¾åˆ©ç”¨æŠ¥å‘Š.zip</a>

and zip files please


```python
"""
Bityun VPN Python Proxy å®ç°
æ”¯æŒè§£æClashé…ç½®ã€è¿æ¥SSæœåŠ¡å™¨ã€æ™ºèƒ½é€‰æ‹©èŠ‚ç‚¹
"""

import yaml
import socket
import struct
import hashlib
import requests
import asyncio
import time
from typing import List, Dict, Optional
from dataclasses import dataclass
from cryptography.hazmat.primitives.ciphers import Cipher, algorithms, modes
from cryptography.hazmat.backends import default_backend
import logging

logging.basicConfig(level=logging.INFO)
logger = logging.getLogger(__name__)


# ============================================
# 1. æ•°æ®ç»“æ„å®šä¹‰
# ============================================

@dataclass
class ProxyNode:
    """ä»£ç†èŠ‚ç‚¹é…ç½®"""
    name: str
    server: str
    port: int
    password: str
    cipher: str
    protocol: str = "ss"
    udp: bool = True
    latency: float = float('inf')
    
    def __repr__(self):
        return f"<ProxyNode {self.name} - {self.server}:{self.port}>"


@dataclass
class ProxyConfig:
    """å®Œæ•´ä»£ç†é…ç½®"""
    nodes: List[ProxyNode]
    rules: List[Dict]
    dns_config: Dict
    proxy_groups: List[Dict]
    
    def get_node_by_name(self, name: str) -> Optional[ProxyNode]:
        """é€šè¿‡åç§°è·å–èŠ‚ç‚¹"""
        for node in self.nodes:
            if node.name == name:
                return node
        return None
    
    def get_nodes_by_region(self, region: str) -> List[ProxyNode]:
        """è·å–æŒ‡å®šåœ°åŒºçš„èŠ‚ç‚¹"""
        return [n for n in self.nodes if region in n.name]


# ============================================
# 2. é…ç½®è§£æå™¨
# ============================================

class ClashConfigParser:
    """Clashé…ç½®æ–‡ä»¶è§£æå™¨"""
    
    @staticmethod
    def parse_yaml_file(file_path: str) -> ProxyConfig:
        """è§£æYAMLé…ç½®æ–‡ä»¶"""
        with open(file_path, 'r', encoding='utf-8') as f:
            data = yaml.safe_load(f)
        return ClashConfigParser.parse_dict(data)
    
    @staticmethod
    def parse_dict(data: Dict) -> ProxyConfig:
        """è§£æé…ç½®å­—å…¸"""
        # è§£æèŠ‚ç‚¹
        nodes = []
        for proxy in data.get('proxies', []):
            if proxy.get('type') == 'ss':
                node = ProxyNode(
                    name=proxy['name'],
                    server=proxy['server'],
                    port=proxy['port'],
                    password=proxy['password'],
                    cipher=proxy['cipher'],
                    udp=proxy.get('udp', True)
                )
                nodes.append(node)
        
        config = ProxyConfig(
            nodes=nodes,
            rules=data.get('rules', []),
            dns_config=data.get('dns', {}),
            proxy_groups=data.get('proxy-groups', [])
        )
        
        logger.info(f"âœ… è§£æå®Œæˆï¼š{len(nodes)} ä¸ªèŠ‚ç‚¹")
        return config
    
    @staticmethod
    def download_subscription(url: str) -> ProxyConfig:
        """ä»è®¢é˜…URLä¸‹è½½é…ç½®"""
        try:
            logger.info(f"ğŸ“¥ ä¸‹è½½è®¢é˜…: {url}")
            response = requests.get(url, timeout=10)
            response.raise_for_status()
            
            # å¯èƒ½æ˜¯base64ç¼–ç 
            try:
                import base64
                content = base64.b64decode(response.text).decode('utf-8')
            except:
                content = response.text
            
            data = yaml.safe_load(content)
            return ClashConfigParser.parse_dict(data)
        except Exception as e:
            logger.error(f"âŒ ä¸‹è½½è®¢é˜…å¤±è´¥: {e}")
            raise


# ============================================
# 3. Shadowsocks å®ç°
# ============================================

class ShadowsocksClient:
    """Shadowsockså®¢æˆ·ç«¯ï¼ˆç®€åŒ–ç‰ˆï¼‰"""
    
    METHOD_SUPPORTED = {
        'aes-128-gcm': (16, 16),  # (key_len, iv_len)
        'aes-256-gcm': (32, 32),
        'chacha20-ietf-poly1305': (32, 32),
    }
    
    def __init__(self, node: ProxyNode):
        self.node = node
        self.cipher = node.cipher
        
        if self.cipher not in self.METHOD_SUPPORTED:
            raise ValueError(f"ä¸æ”¯æŒçš„åŠ å¯†æ–¹æ³•: {self.cipher}")
        
        self.key_len, self.iv_len = self.METHOD_SUPPORTED[self.cipher]
        self.key = self._evp_bytes_to_key(node.password.encode(), self.key_len)
    
    def _evp_bytes_to_key(self, password: bytes, key_len: int) -> bytes:
        """å¯†ç æ´¾ç”Ÿå¯†é’¥ï¼ˆEVP_BytesToKeyï¼‰"""
        m = []
        i = 0
        while len(b''.join(m)) < key_len:
            md = hashlib.md5()
            data = password
            if i > 0:
                data = m[i - 1] + password
            md.update(data)
            m.append(md.digest())
            i += 1
        return b''.join(m)[:key_len]
    
    def _create_cipher(self, iv: bytes, encrypt: bool = True):
        """åˆ›å»ºåŠ å¯†å™¨"""
        if 'gcm' in self.cipher:
            cipher = Cipher(
                algorithms.AES(self.key),
                modes.GCM(iv),
                backend=default_backend()
            )
        elif 'chacha20' in self.cipher:
            from cryptography.hazmat.primitives.ciphers import algorithms as algo
            cipher = Cipher(
                algo.ChaCha20(self.key, iv),
                mode=None,
                backend=default_backend()
            )
        else:
            raise ValueError(f"ä¸æ”¯æŒçš„å¯†ç : {self.cipher}")
        
        return cipher.encryptor() if encrypt else cipher.decryptor()
    
    async def connect(self, target_host: str, target_port: int):
        """è¿æ¥åˆ°ç›®æ ‡ä¸»æœºï¼ˆé€šè¿‡SSæœåŠ¡å™¨ï¼‰"""
        try:
            # 1. è¿æ¥åˆ°SSæœåŠ¡å™¨
            reader, writer = await asyncio.open_connection(
                self.node.server, 
                self.node.port
            )
            
            logger.info(f"ğŸ”— å·²è¿æ¥åˆ° {self.node.name}")
            
            # 2. å‘é€SOCKS5è¯·æ±‚
            # æ„é€ è¯·æ±‚æ•°æ®ï¼š[åœ°å€ç±»å‹][åœ°å€][ç«¯å£]
            request = self._build_request(target_host, target_port)
            
            # 3. åŠ å¯†å¹¶å‘é€
            iv = os.urandom(self.iv_len)
            encryptor = self._create_cipher(iv, encrypt=True)
            encrypted = iv + encryptor.update(request)
            
            writer.write(encrypted)
            await writer.drain()
            
            return reader, writer
            
        except Exception as e:
            logger.error(f"âŒ è¿æ¥å¤±è´¥: {e}")
            raise
    
    def _build_request(self, host: str, port: int) -> bytes:
        """æ„é€ SOCKS5è¯·æ±‚"""
        # åœ°å€ç±»å‹
        if self._is_ip(host):
            atyp = b'\x01'  # IPv4
            addr = socket.inet_aton(host)
        else:
            atyp = b'\x03'  # åŸŸå
            addr = len(host).to_bytes(1, 'big') + host.encode()
        
        # ç«¯å£ï¼ˆå¤§ç«¯åºï¼‰
        port_bytes = struct.pack('>H', port)
        
        return atyp + addr + port_bytes
    
    @staticmethod
    def _is_ip(host: str) -> bool:
        """æ£€æŸ¥æ˜¯å¦æ˜¯IPåœ°å€"""
        try:
            socket.inet_aton(host)
            return True
        except:
            return False


# ============================================
# 4. èŠ‚ç‚¹æµ‹é€Ÿå™¨
# ============================================

class NodeTester:
    """èŠ‚ç‚¹å»¶è¿Ÿæµ‹è¯•"""
    
    @staticmethod
    async def test_latency(node: ProxyNode, timeout: float = 5.0) -> float:
        """æµ‹è¯•èŠ‚ç‚¹å»¶è¿Ÿï¼ˆTCPè¿æ¥ï¼‰"""
        try:
            start = time.time()
            reader, writer = await asyncio.wait_for(
                asyncio.open_connection(node.server, node.port),
                timeout=timeout
            )
            latency = (time.time() - start) * 1000  # æ¯«ç§’
            writer.close()
            await writer.wait_closed()
            
            node.latency = latency
            logger.info(f"âœ… {node.name}: {latency:.0f}ms")
            return latency
        except asyncio.TimeoutError:
            node.latency = float('inf')
            logger.warning(f"â±ï¸ {node.name}: è¶…æ—¶")
            return float('inf')
        except Exception as e:
            node.latency = float('inf')
            logger.error(f"âŒ {node.name}: {e}")
            return float('inf')
    
    @staticmethod
    async def test_all_nodes(nodes: List[ProxyNode]) -> List[ProxyNode]:
        """æµ‹è¯•æ‰€æœ‰èŠ‚ç‚¹"""
        logger.info(f"ğŸ” å¼€å§‹æµ‹è¯• {len(nodes)} ä¸ªèŠ‚ç‚¹...")
        tasks = [NodeTester.test_latency(node) for node in nodes]
        await asyncio.gather(*tasks)
        
        # æŒ‰å»¶è¿Ÿæ’åº
        nodes.sort(key=lambda n: n.latency)
        return nodes


# ============================================
# 5. æ™ºèƒ½é€‰æ‹©å™¨
# ============================================

class NodeSelector:
    """æ™ºèƒ½èŠ‚ç‚¹é€‰æ‹©å™¨"""
    
    def __init__(self, config: ProxyConfig):
        self.config = config
        self.current_node = None
    
    def select_fastest(self, region: Optional[str] = None) -> ProxyNode:
        """é€‰æ‹©æœ€å¿«çš„èŠ‚ç‚¹"""
        nodes = self.config.nodes
        if region:
            nodes = self.config.get_nodes_by_region(region)
        
        if not nodes:
            raise ValueError("æ²¡æœ‰å¯ç”¨èŠ‚ç‚¹")
        
        # æ‰¾åˆ°å»¶è¿Ÿæœ€ä½çš„
        fastest = min(nodes, key=lambda n: n.latency)
        self.current_node = fastest
        logger.info(f"ğŸš€ é€‰æ‹©èŠ‚ç‚¹: {fastest.name} ({fastest.latency:.0f}ms)")
        return fastest
    
    def select_by_name(self, name: str) -> ProxyNode:
        """é€šè¿‡åç§°é€‰æ‹©èŠ‚ç‚¹"""
        node = self.config.get_node_by_name(name)
        if not node:
            raise ValueError(f"æœªæ‰¾åˆ°èŠ‚ç‚¹: {name}")
        self.current_node = node
        return node
    
    def get_available_nodes(self, max_latency: float = 500) -> List[ProxyNode]:
        """è·å–å¯ç”¨èŠ‚ç‚¹ï¼ˆå»¶è¿Ÿå°äºé˜ˆå€¼ï¼‰"""
        return [n for n in self.config.nodes if n.latency < max_latency]


# ============================================
# 6. æœ¬åœ°HTTPä»£ç†æœåŠ¡å™¨
# ============================================

class LocalProxyServer:
    """æœ¬åœ°HTTP/SOCKS5ä»£ç†æœåŠ¡å™¨"""
    
    def __init__(self, config: ProxyConfig, listen_host='127.0.0.1', listen_port=7890):
        self.config = config
        self.listen_host = listen_host
        self.listen_port = listen_port
        self.selector = NodeSelector(config)
        
    async def start(self):
        """å¯åŠ¨ä»£ç†æœåŠ¡å™¨"""
        server = await asyncio.start_server(
            self.handle_client,
            self.listen_host,
            self.listen_port
        )
        
        addr = server.sockets[0].getsockname()
        logger.info(f"ğŸŒ ä»£ç†æœåŠ¡å™¨è¿è¡Œåœ¨ {addr[0]}:{addr[1]}")
        
        async with server:
            await server.serve_forever()
    
    async def handle_client(self, client_reader, client_writer):
        """å¤„ç†å®¢æˆ·ç«¯è¿æ¥"""
        try:
            # è¯»å–ç¬¬ä¸€ä¸ªå­—èŠ‚åˆ¤æ–­åè®®
            first_byte = await client_reader.read(1)
            
            if first_byte == b'\x05':
                # SOCKS5åè®®
                await self.handle_socks5(client_reader, client_writer, first_byte)
            else:
                # HTTPåè®®
                await self.handle_http(client_reader, client_writer, first_byte)
                
        except Exception as e:
            logger.error(f"âŒ å¤„ç†å®¢æˆ·ç«¯å¤±è´¥: {e}")
        finally:
            client_writer.close()
            await client_writer.wait_closed()
    
    async def handle_socks5(self, reader, writer, first_byte):
        """å¤„ç†SOCKS5è¯·æ±‚"""
        # å®ç°SOCKS5åè®®...
        logger.info("ğŸ”Œ SOCKS5è¯·æ±‚")
        pass
    
    async def handle_http(self, reader, writer, first_byte):
        """å¤„ç†HTTPä»£ç†è¯·æ±‚"""
        logger.info("ğŸŒ HTTPè¯·æ±‚")
        # å®ç°HTTP CONNECTæ–¹æ³•...
        pass


# ============================================
# 7. ä¸»ç¨‹åº
# ============================================

import os

async def main():
    """ä¸»å‡½æ•°"""
    
    print("=" * 60)
    print("ğŸš€ Bityun VPN Python Proxy")
    print("=" * 60)
    
    # 1. åŠ è½½é…ç½®
    config_file = "1766745722873_bityun_qq.yaml"
    
    # æ–¹å¼1: ä»æœ¬åœ°æ–‡ä»¶åŠ è½½
    if os.path.exists(config_file):
        logger.info("ğŸ“‚ ä»æœ¬åœ°æ–‡ä»¶åŠ è½½é…ç½®...")
        config = ClashConfigParser.parse_yaml_file(config_file)
    else:
        # æ–¹å¼2: ä»è®¢é˜…URLä¸‹è½½
        subscription_url = "https://times1766152644.subxiandan.top:9604/v2b/bityun/api/v1/client/subscribe?token=34bc20bef5fc9212539fb413b596c3af"
        config = ClashConfigParser.download_subscription(subscription_url)
    
    print(f"âœ… åŠ è½½äº† {len(config.nodes)} ä¸ªèŠ‚ç‚¹\n")
    
    # 2. æµ‹è¯•èŠ‚ç‚¹å»¶è¿Ÿ
    logger.info("ğŸ” å¼€å§‹æµ‹è¯•èŠ‚ç‚¹å»¶è¿Ÿ...")
    await NodeTester.test_all_nodes(config.nodes)
    
    # 3. é€‰æ‹©æœ€å¿«èŠ‚ç‚¹
    selector = NodeSelector(config)
    
    # æ˜¾ç¤ºå¯ç”¨èŠ‚ç‚¹
    available = selector.get_available_nodes(max_latency=500)
    print(f"\nğŸ“Š å¯ç”¨èŠ‚ç‚¹ ({len(available)}):")
    for i, node in enumerate(available[:10], 1):
        print(f"  {i}. {node.name:40s} {node.latency:6.0f}ms")
    
    fastest = selector.select_fastest()
    print(f"\nğŸš€ è‡ªåŠ¨é€‰æ‹©: {fastest.name} ({fastest.latency:.0f}ms)")
    
    # 4. æµ‹è¯•è¿æ¥
    print(f"\nğŸ”— æµ‹è¯•è¿æ¥åˆ°Google...")
    ss_client = ShadowsocksClient(fastest)
    try:
        reader, writer = await ss_client.connect("www.google.com", 443)
        print("âœ… è¿æ¥æˆåŠŸï¼")
        writer.close()
        await writer.wait_closed()
    except Exception as e:
        print(f"âŒ è¿æ¥å¤±è´¥: {e}")
    
    # 5. å¯åŠ¨æœ¬åœ°ä»£ç†æœåŠ¡å™¨ï¼ˆå¯é€‰ï¼‰
    # proxy_server = LocalProxyServer(config)
    # await proxy_server.start()


if __name__ == "__main__":
    asyncio.run(main())
```


<tool>
python fake-headers
loguru
    except Exception:
        exc_type, exc_value, exc_traceback = sys.exc_info()
        error_message = repr(
            traceback.format_exception(exc_type, exc_value, exc_traceback)
        )
        logger.error(f"xxx: {error_message}")
<tool>


task
1. design proxy based on config.yaml
2. first get and save json ï¼ˆincluding all useful infos) for all stages including zip url using proxy and fake-headers
3. download zip fileï¼Œå¹¶ä¸”è§£å‹ï¼Œè§£å‹çš„æ–‡ä»¶å‘½åè¦æ˜¯stage2 ä¸­è·å¾—çš„titleï¼Œ  using proxy and fake-headers
4. design æå…¶å®Œå–„çš„å±‚çº§æ–‡ä»¶ä¿å­˜å‘½å and è®¾è®¡æ–­ç‚¹ä¸‹è½½æœºåˆ¶ï¼ˆå› ä¸ºå¯èƒ½å‡ºç°ç½‘ç»œé—®é¢˜ï¼‰ï¼Œä»¥åŠä¸‹è½½çš„æ–‡ä»¶ä¸èƒ½åå¤ä¸‹è½½


design code category and give me file by file